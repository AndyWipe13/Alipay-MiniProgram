"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var props_1 = require("./props");
var promisify_1 = require("../_util/promisify");
var value_1 = tslib_1.__importDefault(require("../mixins/value"));
Component({
    props: props_1.UploaderDefaultProps,
    mixins: [(0, value_1.default)({
            defaultValueKey: 'defaultFileList',
            valueKey: 'fileList',
            transformValue: function (fileList) {
                if (fileList === void 0) { fileList = []; }
                return {
                    needUpdate: true,
                    value: fileList.map(function (item) {
                        var file = tslib_1.__assign({}, item);
                        if (typeof item.url === 'undefined') {
                            file.url = '';
                        }
                        if (typeof item.uid === 'undefined') {
                            file.uid = String(Math.random());
                        }
                        if (typeof item.status === 'undefined') {
                            item.status = 'done';
                        }
                        return file;
                    }),
                };
            },
        })],
    methods: {
        chooseImage: function () {
            return tslib_1.__awaiter(this, void 0, void 0, function () {
                var _a, onBeforeUpload, onUpload, fileList, _b, maxCount, sourceType, localFileList, chooseImageRes, err_1, beforeUploadRes, err_2, tasks;
                var _this = this;
                return tslib_1.__generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            _a = this.props, onBeforeUpload = _a.onBeforeUpload, onUpload = _a.onUpload;
                            if (!onUpload) {
                                throw new Error('need props onUpload');
                            }
                            fileList = this.getValue();
                            _b = this.props, maxCount = _b.maxCount, sourceType = _b.sourceType;
                            _c.label = 1;
                        case 1:
                            _c.trys.push([1, 3, , 4]);
                            return [4 /*yield*/, (0, promisify_1.chooseImage)({
                                    count: typeof maxCount === 'undefined' ? Infinity : (maxCount - fileList.length),
                                    sourceType: sourceType,
                                })];
                        case 2:
                            chooseImageRes = _c.sent();
                            localFileList = (chooseImageRes.tempFiles || chooseImageRes.tempFilePaths || chooseImageRes.apFilePaths || chooseImageRes.filePaths || []).map(function (item) {
                                if (typeof item === 'string') {
                                    return {
                                        path: item,
                                    };
                                }
                                if (item.path) {
                                    return {
                                        path: item.path,
                                        size: item.size,
                                    };
                                }
                            }).filter(function (item) { return !!item; });
                            return [3 /*break*/, 4];
                        case 3:
                            err_1 = _c.sent();
                            if (this.props.onChooseImageError) {
                                this.props.onChooseImageError(err_1);
                            }
                            return [2 /*return*/];
                        case 4:
                            if (!onBeforeUpload) return [3 /*break*/, 8];
                            _c.label = 5;
                        case 5:
                            _c.trys.push([5, 7, , 8]);
                            return [4 /*yield*/, onBeforeUpload(localFileList)];
                        case 6:
                            beforeUploadRes = _c.sent();
                            if (beforeUploadRes === false) {
                                return [2 /*return*/];
                            }
                            if (Array.isArray(beforeUploadRes)) {
                                localFileList = beforeUploadRes;
                            }
                            return [3 /*break*/, 8];
                        case 7:
                            err_2 = _c.sent();
                            return [2 /*return*/];
                        case 8:
                            tasks = localFileList.map(function (file) { return _this.uploadFile(file); });
                            return [4 /*yield*/, Promise.all(tasks)];
                        case 9:
                            _c.sent();
                            return [2 /*return*/];
                    }
                });
            });
        },
        uploadFile: function (localFile) {
            return tslib_1.__awaiter(this, void 0, void 0, function () {
                var onUpload, uid, tempFileList, url, err_3;
                return tslib_1.__generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            onUpload = this.props.onUpload;
                            uid = String(Math.random());
                            tempFileList = tslib_1.__spreadArray(tslib_1.__spreadArray([], this.getValue(), true), [{
                                    path: localFile.path,
                                    size: localFile.size,
                                    uid: uid,
                                    status: 'uploading'
                                }], false);
                            if (!this.isControlled()) {
                                this.update(tempFileList);
                            }
                            if (this.props.onChange) {
                                this.props.onChange(tempFileList);
                            }
                            _a.label = 1;
                        case 1:
                            _a.trys.push([1, 3, , 4]);
                            return [4 /*yield*/, onUpload(localFile)];
                        case 2:
                            url = _a.sent();
                            if (typeof url !== 'string' || !url) {
                                this.updateFile(uid, {
                                    status: 'error',
                                });
                                return [2 /*return*/];
                            }
                            this.updateFile(uid, {
                                status: 'done',
                                url: url,
                            });
                            return [3 /*break*/, 4];
                        case 3:
                            err_3 = _a.sent();
                            this.updateFile(uid, {
                                status: 'error',
                            });
                            return [3 /*break*/, 4];
                        case 4: return [2 /*return*/];
                    }
                });
            });
        },
        updateFile: function (uid, file) {
            var fileList = this.getValue();
            var tempFileList = fileList.map(function (item) {
                if (item.uid === uid) {
                    return tslib_1.__assign(tslib_1.__assign({}, item), file);
                }
                return item;
            });
            if (!this.isControlled()) {
                this.update(tempFileList);
            }
            if (this.props.onChange) {
                this.props.onChange(tempFileList);
            }
        },
        onRemove: function (e) {
            return tslib_1.__awaiter(this, void 0, void 0, function () {
                var fileList, _a, onRemove, onChange, uid, file, result, tempFileList;
                return tslib_1.__generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            fileList = this.getValue();
                            _a = this.props, onRemove = _a.onRemove, onChange = _a.onChange;
                            uid = e.target.dataset.uid;
                            file = fileList.find(function (item) { return item.uid === uid; });
                            if (!onRemove) return [3 /*break*/, 2];
                            return [4 /*yield*/, onRemove(file)];
                        case 1:
                            result = _b.sent();
                            if (result === false) {
                                return [2 /*return*/];
                            }
                            _b.label = 2;
                        case 2:
                            tempFileList = fileList.filter(function (item) { return item.uid !== uid; });
                            if (!this.isControlled()) {
                                this.update(tempFileList);
                            }
                            if (onChange) {
                                onChange(tempFileList);
                            }
                            return [2 /*return*/];
                    }
                });
            });
        },
        onPreview: function (e) {
            var uid = e.target.dataset.uid;
            var fileList = this.getValue();
            var file = fileList.find(function (item) { return item.uid === uid; });
            if (this.props.onPreview) {
                this.props.onPreview(file);
            }
        },
    }
});